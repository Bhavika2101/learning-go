// ********RoostGPT********
/*
Test generated by RoostGPT for test java-turbo-test using AI Type Open AI and AI Model gpt-4-1106-preview

ROOST_METHOD_HASH=hammingDistance_0d749de292
ROOST_METHOD_SIG_HASH=hammingDistance_f17e8d7bc0


*/

// ********RoostGPT********
// ********RoostGPT********

package HammingDistance

import (
	"log"
	"strings"
	"testing"
)

func TestHammingDistance(t *testing.T) {
	tests := []struct {
		name     string
		a        string
		b        string
		expected int
		wantErr  bool
		errMsg   string
	}{
		{
			name:     "No Difference",
			a:        "test",
			b:        "test",
			expected: 0,
			wantErr:  false,
		},
		{
			name:     "Single Difference",
			a:        "test",
			b:        "tast",
			expected: 1,
			wantErr:  false,
		},
		{
			name:    "Different Lengths",
			a:       "test",
			b:       "testa",
			wantErr: true,
			errMsg:  "Strings are of different length",
		},
		{
			name:     "All Differences",
			a:        "test",
			b:        "abcd",
			expected: 4,
			wantErr:  false,
		},
	}

	originalLogFatal := log.Fatal
	defer func() { log.Fatal = originalLogFatal }()

	var logs strings.Builder
	log.SetOutput(&logs)

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			logs.Reset()
			if tt.wantErr {
				log.Fatal = func(v ...interface{}) {
					logs.WriteString(v[0].(string))
				}

				defer func() {
					if r := recover(); r != nil {
						if logs.String() != tt.errMsg {
							t.Errorf("Expected log.Fatal with message '%s', but got '%s'", tt.errMsg, logs.String())
						}
					} else {
						t.Errorf("Expected log.Fatal to be called for test '%s'", tt.name)
					}
				}()

				hammingDistance(tt.a, tt.b)
			} else {
				if result := hammingDistance(tt.a, tt.b); result != tt.expected {
					t.Errorf("Expected Hamming distance of %d for test '%s', but got %d", tt.expected, tt.name, result)
				}
			}
		})
	}
}

// ***********************
// FUNCTION FOR WHICH TESTS WERE GENERATED:
func hammingDistance(a, b string) int {
	if len(a) != len(b) {
		log.Fatal("Strings are of different length")
	}
	var distance int = 0
	for i := 0; i < len(a); i++ {
		if a[i] != b[i] {
			distance++
		}
	}
	return distance
}

// ***********************
